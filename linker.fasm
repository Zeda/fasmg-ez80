; macros to assemble ez80 instructions
include 'ez80.inc'

; create a global namespace
global? = 0
; create a segments namespace
segments? equ
namespace segments?
	; initialize the start of each segment
	code? = 0D1A881h
	data? = code.top
	text? = data.top
	strsect? = text.top
	bss? = 0D031F6h
	discard? = 0

	; create a list of all the segments
	segments. reequ code?
	segments.   equ data?
	segments.   equ text?
	segments.   equ strsect?
	segments.   equ bss?
	segments.   equ discard?

	; this is run at every segment change
	macro prolog name
		namespace segments?
			; raw match to change the context of the
			; segment name into this namespace
			rmatch rname, name
				current reequ rname?
			end rmatch
			; create a virtual block for the code/data
			virtual at current
		end namespace
	end macro
	; this is run before the next segment change
	macro epilog
		; we need to remember the output area, start, and end of
		; this partial segment so that it can be emitted later,
		; so create unique vars to store this information
		local area, base, top
		namespace segments?
				; match to expand the symbolic var current to
				; the actual name
				match segment, current
				area::
					base = $$
					top = $
					; update the current location in the segment
					segment = top
					; store links to the local vars in a list
					; associated with the segment
					segment.list? equ area base top
				end match
			end virtual
		end namespace
	end macro
end namespace
; iterate through the segment list
irpv segment, segments?
	; remember where each segment starts
	segment.base? := segment
end irpv

; ignore directive specifying the originating source file
macro file? name
end macro
; implement segment change as...
macro segment? name
	namespace segments?
		; ...closing the previous segment...
		epilog
		; ...and opening the new one
		prolog name
	end namespace
end macro
; emit 3 byte values
macro dw24? vals
	emit 3: vals
end macro
macro xref? arg
	match name : space, arg
		; ...ignoring any specified space, and...
		xref? name
	else
		; ...copying the var from the global
		; namespace into the file-local one
		arg := global?.arg
	end match
end macro
; implement external definitions by...
macro xdef? arg
	match name : space, arg
		; ...ignoring any specified space, and...
		xdef? name
	else
		; ...copying the var from the file-local
		; namespace into the global one
		global?.arg := arg
	end match
end macro
; discard any input after the end directive
; FIXME: technically this should skip it with an
; if 0, but I'm not sure how to conditionally end if
macro end?!
	segment discard
end macro
; hack to make end by itself look like "end." activating
; the previous macro, and make end <ident> look like
; "end.<ident>" which is also valid
macro end?! name
	end.name
end.macro

; check for any input files
match any, files?
	; iterate through all of the input files
	iterate file, any
		; create a namespace named after this input file
		file = 0
		namespace file
			; luckily for us, .assume is the only dot-prefixed
			; directive, and it always appears before any labels,
			; so redirect it to the real directive in each namespace
			macro .assume? mode&
				assume? mode
			end macro
			; set the default segment, and open
			; for the next segment change
			segments?.prolog CODE
			; parse this input file
			include `file
			; close for the the last segment change
			segments?.epilog
		end namespace
	end iterate
end match

; iterate through the segment list
irpv segment, segments?
	; remember the end and length of each segment
	segment.top? := segment
	segment.length? := segment.top - segment.base
end irpv
; wait until everything else is assmebled before
; emitting the output file
postpone ?
	; trim the segments that shouldn't be emitted
	repeat 2
		restore segments?
	end repeat
	; compute the output program length...
	length = 0
	; ...by iterating through all the segments...
	irpv segment, segments?
		; ...and summing all of their lengths
		length = length + segment.length
	end irpv
	; output the output file header
	dq '**TI83F*'
	db 26, 10, 0
	rb 42
	dw 2 + 13 + 2 + 2 + 2 + length
	; compute checksum from this point onwards
	; FIXME: this might be cleaner with
	; a pseudo segment for the header
	org 0
	dw 13, 2 + 2 + length
	db 6
	match any, name?
		dq `any
	else ; if no name specified
		dq 'A'
	end match
	dw 0, 2 + 2 + length, 2 + length, 7BEFh
	; checksum the header, by...
	checksum = 0
	repeat $ - $$, addr: $$
		;...reading each byte...
		load a: byte from addr
		;...and updating the checksum
		checksum = (checksum + a) and 0FFFFh
	end repeat
	; iterate through the segments
	irpv segment, segments?
		; iterate through each block in that segment
		irpv entry, segment.list?
			; grab each var in its original context
			match area base top, entry
				; iterate through each byte
				repeat top - base, addr: base
					; read the next byte
					load a: byte from area: addr
					; emit it
					db a
					; update the checksum
					checksum = (checksum + a) and 0FFFFh
				end repeat
			end match
		end irpv
	end irpv
	; emit the checksum
	dw checksum
end postpone
