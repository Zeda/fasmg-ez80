; macros to assemble ez80 instructions
include 'ez80.inc'

; create a global namespace
global?::

macro files? args&
	match first =, rest, args
		files? first
		files? rest
	else match first= rest, args
		files? first
		files? rest
	else
		define files? args
	end match
end macro
macro name? args&
	if defined args & args eqtype ''
		redefine name? `args
	else
		redefine name? args
	end if
end macro
macro symbol? args&
	rmatch var == val, args
		namespace segments?
			global?.var = val
		end namespace
	else
		err 'define syntax error'
	end rmatch
end macro
macro range? args&
	match first =, rest, args
		range? first
		range? rest
	else match segment lower : upper, args
		segments? equ segments?.segment?
		segments?.segment?::
		segments?.segment?.name? := `segment
		segments?.segment?.base? := lower
		segments?.segment?.high? := upper
	else
		err 'range syntax error'
	end match
end macro
macro locate? args&
	match segment =at? val, args
		segments? equ segments?.segment?
		segments?.segment?::
		segments?.segment?.name? := `segment
		segments?.segment?.base? := val
	else
		err 'locate syntax error'
	end match
end macro
macro order? args&
	match first =, second =, rest, args
		order? first, second
		order? second, rest
	else match first =, second, args
		segments? equ segments?.second?
		segments?.second?::
		segments?.second?.name? := `second
		segments?.second?.base? := segments?.first?.top?
	else
		err 'order syntax error'
	end match
end macro
macro merge? args&
	match segment == list, args
		order? list
		segments?.segment?::
		segments?.segment?.name? := `segment
		iterate each, list
			segments?.segment?.base? := segments?.each?.base?
			indx %%
			segments?.segment?.top? := segments?.each?.top?
			if defined segments?.each?.high?
				segments?.segment?.high? := segments?.each?.high?
			end if
			break
		end iterate
		segments?.segment?.length? := segments?.segment?.top? - segments?.segment?.base?
	else
		err 'merge syntax error'
	end match
end macro

; check if there are any segments defined
if ~defined segments?
	err 'No segments defined'
end if

; iterate through the segment list
irpv segment, segments?
	; initialize each segment to its base
	segment.current = segment.base
end irpv

; ignore directive specifying the originating source file
macro file? name
end macro
; this is run at every segment change
macro segments?.prolog name
	namespace segments?
		; raw match to change the context of the
		; segment name into this namespace
		rmatch rname, name
			if defined rname
				current reequ rname
			else
				err 'Undefined segment ', `rname
			end if
			; create a virtual block for the code/data
			virtual at rname.current
		end rmatch
	end namespace
end macro
; this is run before the next segment change
macro segments?.epilog
	; we need to remember the output area, start, and end of
	; this partial segment so that it can be emitted later,
	; so create unique vars to store this information
	local area, base, top
	namespace segments?
			; match to expand the symbolic var current to
			; the actual name
			match segment, current
			area::
				base = $$
				top = $
				; update the current location in the segment
				segment.current = top
				; store links to the local vars in a list
				; associated with the segment
				segment.list? equ area base top
			end match
		end virtual
	end namespace
end macro
; implement segment change as...
macro segment? name
	; ...closing the previous segment...
	segments?.epilog
	; ...and opening the new one
	segments?.prolog name?
end macro
; emit 3 byte values
macro dw24? vals
	emit 3: vals
end macro
macro ds? val
	rb val
end macro
; implement external references by...
macro xref? arg
	match name : space, arg
		; ...ignoring any specified space, and...
		xref? name
	else
		; ...copying the var from the global
		; namespace into the file-local one
		arg := global?.arg
	end match
end macro
; implement external definitions by...
macro xdef? arg
	match name : space, arg
		; ...ignoring any specified space, and...
		xdef? name
	else
		; ...copying the var from the file-local
		; namespace into the global one
		global?.arg := arg
	end match
end macro
; discard any input after the end directive
macro end?!
	macro segments?.epilog!
		end if
		purge segments?.epilog
		segments?.epilog
	end macro
		if 0
end macro
; hack to make end by itself look like "end." activating
; the previous macro, and make end <ident> look like
; "end.<ident>" which is also valid
macro end?! name
	end.name
end.macro

; check for any input files
if ~defined files?
	err 'No input files specified with -i "files <file list>"'
end if

; iterate through all of the input files
irpv file, files?
	; create a namespace named after this input file
	file::
	namespace file
		; luckily for us, .assume is the only dot-prefixed
		; directive, and it always appears before any labels,
		; so redirect it to the real directive in each namespace
		macro .assume? mode&
			assume? mode
		end macro
		; set the default segment, and open
		; for the next segment change
		irpv segment, segments?
			segments?.prolog segment
			break
		end irpv
		; parse this input file
		include `file
		; close for the the last segment change
		segments?.epilog
	end namespace
end irpv

; iterate through the segment list
irpv segment, segments?
	; remember the end and length of each segment
	segment.top? := segment.current
	segment.length? := segment.top - segment.base
end irpv
; wait until everything else is assmebled before
; emitting the output file
postpone ?
	; compute the output program length...
	length = 0
	; ...by iterating through all the segments...
	irpv segment, segments?
		; skip segments that aren't emitted
		if ~defined segment.high
			; ...and summing all of their lengths
			length = length + segment.length
		else if segment.top > segment.high
			repeat 1, length: segment.length, over: segment.top - segment.high, max: segment.high - segment.base
				err 'Segment ', segment.name, ' is ', `length, ' bytes, ', `over, ' bytes larger than the maximum of ', `max, ' bytes'
			end repeat
		end if
	end irpv
	; output the output file header
	dq '**TI83F*'
	db 26, 10, 0
	rb 42
	dw 2 + 13 + 2 + 2 + 2 + length
	; compute checksum from this point onwards
	; FIXME: this might be cleaner with
	; a pseudo segment for the header
	org 0
	dw 13, 2 + 2 + length
	db 6
	if defined name?
		dq name?
	else
		err 'No output filename specified with -i "name <name>"'
	end if
	dw 0, 2 + 2 + length, 2 + length, 7BEFh
	; checksum the header, by...
	checksum = 0
	repeat $ - $$, addr: $$
		;...reading each byte...
		load a: byte from addr
		;...and updating the checksum
		checksum = (checksum + a) and 0FFFFh
	end repeat
	; iterate through the segments
	irpv segment, segments?
		; skip segments that aren't emitted
		if ~defined segment.high
			; iterate through each block in that segment
			irpv each, segment.list?
				; grab each var in its original context
				match area base top, each
					; iterate through each byte
					repeat top - base, addr: base
						; read the next byte
						load a: byte from area: addr
						; emit it
						db a
						; update the checksum
						checksum = (checksum + a) and 0FFFFh
					end repeat
				end match
			end irpv
		end if
	end irpv
	; emit the checksum
	dw checksum
end postpone
