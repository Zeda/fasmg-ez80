include 'tiformat.inc'
define ez80 ez80
namespace ez80
	include 'ez80.inc'
end namespace
macro import $        : $        , \
             $$       : $$       , \
             and      : and      , \
             at       : at       , \
             break    : break    , \
             define   : define   , \
             defined  : defined  , \
             display  : display  , \
             dup      : dup      , \
             else     : else     , \
             emit     : emit     , \
             end      : end      , \
             equ      : equ      , \
             err      : err      , \
             esc      : esc      , \
             eval     : eval     , \
             ez80     : ez80     , \
             from     : from     , \
             if       : if       , \
             include  : include  , \
             irpv     : irpv     , \
             iterate  : iterate  , \
             label    : label    , \
             lengthof : lengthof , \
             load     : load     , \
             local    : local    , \
             macro    : macro    , \
             match    : match    , \
             mod      : mod      , \
             namespace: namespace, \
             purge    : purge    , \
             rb       : rb       , \
             reequ    : reequ    , \
             repeat   : repeat   , \
             restore  : restore  , \
             restruc  : restruc  , \
             rmatch   : rmatch   , \
             segment  : segment  , \
             shl      : shl      , \
             shr      : shr      , \
             store    : store    , \
             struc    : struc    , \
             used     : used     , \
             virtual  : virtual  , \
             xor      : xor
	local global, files, segments, output

	macro files.libs.parse file, offset, usedfunc, usedlib
		local private
		namespace private
			macro library?! name, version
				end if
					if usedlib
						emit 1: $C0, name, 0, version
					end if
				if 0
			end macro
			macro export?! function
				end if
					namespace ez80
						if used global._#function
							usedfunc = 1
						global._#function:
							jp offset
						end if
						offset = offset + word + @ez80.il
					end namespace
				if 0
			end macro
			if 0
				esc include! file
			end if
		end namespace
	end macro
	macro files.libs.handle file
		local offset, usedfunc, usedlib
		offset = 0
		usedfunc = 0
		files.libs.parse file, offset, usedfunc, usedlib
		usedlib = usedfunc
	end macro

	macro files.deps.check file, usedsrc
		local private
		namespace private
			iterate name, DEF, GLOBAL, PUBLIC, XDEF
				iterate style, name, .name
					macro style?! symbols*&
						end if
							iterate symbol, symbols
								if used global.symbol
									usedsrc = 1
								end if
							end iterate
						if 0
					end macro
				end iterate
			end iterate
			if 0
				esc include! file
			end if
		end namespace
	end macro
	macro files.parse file
		local private
		namespace private
			?$ equ $
			?SHL? equ shl
			?SHR? equ shr
			iterate name, LIST, NEWPAGE, NOLIST, PAGE
				macro name?
				end macro
			end iterate
			iterate name, CPU, FILE, TITLE
				macro name? arg*
				end macro
			end iterate
			macro DEFINE? args*&
			end macro
			iterate name, COPY, INCLUDE
				macro name? path*
					include path
				end macro
			end iterate
			iterate name, EXTERN, EXTERNAL, REF, XREF
				macro name? symbols*&
					match list : space, symbols
						name? list
					else
						iterate symbol, symbols
							symbol := global.symbol
						end iterate
					end match
				end macro
			end iterate
			iterate name, DEF, GLOBAL, PUBLIC, XDEF
				macro name? symbols*&
					iterate symbol, symbols
						global.symbol := symbol
					end iterate
				end macro
			end iterate
			struc (symbol) EQU? expr*
				local error
				if ~defined error & defined symbol | error
					err 'Symbol "', `symbol, '" already defined'
					error = 1
				else
					error = 0
				end if
				?symbol = expr
			end struc
			iterate name, VAR, SET
				struc (symbol) name? expr*
					?symbol = expr
				end struc
			end iterate
			macro DS? count
				local c
				c = count
				rb c
			end macro
			struc DS? count
			.:	DS? count
			end struc
			iterate <def,blk,size*>, B,B,1, W,W,2, W24,P,3, L,L,4
				macro D#def? vals*&
					local v
					iterate val, vals
						v = val
						emit size: v
					end iterate
				end macro
				macro BLK#blk? count*, init
					local c, i
					c = count
					match, init
						emit size: c dup ?
					else
						i = init
						emit size: c dup i
					end match
				end macro
				iterate name, D#def, BLK#blk
					struc name? args&
					.:	name? args
					end struc
				end iterate
			end iterate
			iterate <name,alias*>, TRIO,DW24, DF,DL
				macro name? vals*&
					alias? vals
				end macro
				struc name? args&
				.:	name? args
				end struc
			end iterate
			macro ALIGN? val*
				local v
				v = val
				rb v-1 - ($ + v-1) mod v
			end macro
			macro SEGMENT? name*
				segment name
			end macro
			macro ASSUME? expr*
				namespace ez80
					assume? expr
				end namespace
			end macro
			iterate register, B, NZ, Z, NC, C, PO, PE, P, M, D, E,  \
			                  H, IXH, IYH, L, IXL, IYL, F, A, I, R, \
			                  MB, BC, DE, HL, IX, IY, SP, AF, AF'
				register? := ez80.register?
			end iterate
			iterate suffix, , .s?, .l?, .is?, .il?, .sis?, .sil?, .lis?, .lil?
				irpv name, ez80.@ez80.oplist
					rmatch rname, name
						define rname rname
						macro rname#suffix args&
							namespace ez80
								name#suffix args
							end namespace
						end macro
					end rmatch
				end irpv
				macro jr?#suffix args&
					namespace ez80
						jq?#suffix args
					end namespace
				end macro
			end iterate
			macro COMMENT? delim*&
				end match
				local inside
				inside = 0
				macro ?! line&
					local length, text
					length = 0
					if inside
						length = lengthof `line
						text = `line
					else if `line = 'end match'
						inside = 1
						length = lengthof `delim - 1
						text = `delim shr 8
					end if
					repeat length
						if ~text xor `delim and $FF
							purge ?
							break
						end if
						text = text shr 8
					end repeat
				end macro
			end macro
			macro END?!
				end if
				if 0
			end macro
			macro ? line&
				match .rest, line
					rest
				else match first= .rest, line
					first rest
				else
					line
				end match
			end macro
			if 1
				include file
			end if
			purge ?
		end namespace
	end macro
	macro files.handle file
		files.parse file
	end macro
	macro files.deps.handle file
		local usedsrc
		usedsrc = 0
		files.deps.check file, usedsrc
		if usedsrc
			files.parse file
		end if
	end macro

	macro symbol? args&
		iterate arg, args
			rmatch symbol == value, arg
				namespace segments
					global.symbol := value
				end namespace
			else
				'Syntax error in symbol arguments'
			end rmatch
		end iterate
	end macro

	iterate name, deps, libs
		macro name? args*&
			iterate arg, args
				match first= rest, arg
					name? first
					name? rest
				else if `arg and $FF = "'"
					files.name equ arg
				else
					files.name equ `arg
				end if
			end iterate
		end macro
	end iterate
	macro source? arg*, cond:1
		namespace segments
			if cond
				if `arg and $FF = "'"
					files equ arg
				else
					files equ `arg
				end if
			end if
		end namespace
	end macro

	macro locate? args&
		iterate arg, args
			rmatch name =at? location, arg
				segments equ segments.name?
				namespace segments
					name? := `name
					name.base? := location
				end namespace
			else
				err 'Syntax error in locate argument'
			end rmatch
		end iterate
	end macro
	macro range? args&
		iterate arg, args
			rmatch name lower : upper, arg
				locate name at lower
				namespace segments
					name.high? := upper
				end namespace
			else
				err 'Syntax error in range arguments'
			end rmatch
		end iterate
	end macro
	macro order? args&
		match first =, second =, rest, args
			order first, second
			order second, rest
		else match first =, second, args
			locate second at first.base + first.length
		else
			err 'Not enough order arguments'
		end match
	end macro
	macro merge? args&
		match name == list, args
			order list
			iterate segment, list
				locate name at segment.base
				indx %%
				namespace segments
					name.top? := segment.base + segment.length
					if defined segment.high
						name.high? := segment.high
					end if
				end namespace
				break
			end iterate
		else
			err 'Syntax error in merge arguments'
		end match
	end macro

	macro segment name*
		end virtual
		virtual segments.name.area
	end macro

	if ~defined files
		err 'Please pass the input files with -i''source "file"[, "cond"]'''
	else if ~defined segments
		err 'No segments defined'
	else
		restore output.base, output.top ; forbid forward reference
		irpv segment, segments
			namespace segment
				virtual at base
				area?::
				end virtual
				if ~defined output.base | output.base > base & ~defined high
					output.base = base
				end if
			end namespace
		end irpv
		irpv file, files
			virtual segments.code.area
				files.handle file
			end virtual
		end irpv
		irpv file, files.deps
			virtual segments.code.area
				files.deps.handle file
			end virtual
		end irpv
		irpv file, files.libs
			virtual segments.libs.area
				files.libs.handle file
			end virtual
		end irpv
		irpv segment, segments
			namespace segment
				virtual area
					top? := $
					length? := $ - $$
				end virtual
				if ~defined high
					if ~defined output.top | output.top < top
						output.top = top
					end if
				else if top > high
					repeat 1, len: length, over: top - high, max: high - base
						err 'Segment ', segment, ' is ', `len, ' bytes, ',  \
						    `over, ' bytes larger than the maximum of ', \
						    `max, ' bytes'
					end repeat
				end if
			end namespace
		end irpv
		org output.base
		rb output.top - $
		postpone ?
			irpv segment, segments
				namespace segment
					if ~defined high
						load output: length from area: base
						store output: length at base
					end if
				end namespace
			end irpv
		end postpone
	end if
end macro
import
purge import
