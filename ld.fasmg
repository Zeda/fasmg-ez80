include 'tiformat.inc'
define ez80 ez80
namespace ez80
	include 'ez80.inc'
end namespace
macro import $        : $        , \
             $$       : $$       , \
             and      : and      , \
             at       : at       , \
             break    : break    , \
             define   : define   , \
             defined  : defined  , \
             display  : display  , \
             dup      : dup      , \
             else     : else     , \
             emit     : emit     , \
             end      : end      , \
             equ      : equ      , \
             err      : err      , \
             esc      : esc      , \
             eval     : eval     , \
             ez80     : ez80     , \
             from     : from     , \
             if       : if       , \
             include  : include  , \
             irpv     : irpv     , \
             iterate  : iterate  , \
             label    : label    , \
             lengthof : lengthof , \
             load     : load     , \
             local    : local    , \
             macro    : macro    , \
             match    : match    , \
             mod      : mod      , \
             namespace: namespace, \
             purge    : purge    , \
             rb       : rb       , \
             reequ    : reequ    , \
             repeat   : repeat   , \
             restore  : restore  , \
             rmatch   : rmatch   , \
             segment  : segment  , \
             shl      : shl      , \
             shr      : shr      , \
             store    : store    , \
             struc    : struc    , \
             used     : used     , \
             virtual  : virtual  , \
             xor      : xor
	local global, sources, libsources, segments, outbase, outtop, outtemp

	macro parselib file, offset, usedfunc, usedlib
		local private
		namespace private
			macro library?! name, version
				end if
					if usedlib
						emit 1: $C0, name, 0, version
					end if
				if 0
			end macro
			macro export?! function
				end if
					namespace ez80
						if used global._#function
							usedfunc = 1
						global._#function:
							jp offset
						end if
						offset = offset + word + @ez80.il
					end namespace
				if 0
			end macro
			if 0
				esc include! file
			end if
		end namespace
	end macro
	macro lib file
		local offset, usedfunc, usedlib
		offset = 0
		usedfunc = 0
		parselib file, offset, usedfunc, usedlib
		usedlib = usedfunc
	end macro

	macro checksrc file, usedsrc
		local private
		namespace private
			iterate name, DEF, GLOBAL, PUBLIC, XDEF
				macro name?! symbols*
					end if
						iterate symbol, symbols
							if used global.symbol
								usedsrc = 1
							end if
						end iterate
					if 0
				end macro
			end iterate
			if 0
				esc include! file
			end if
		end namespace
	end macro
	macro parsesrc file
		local private
		namespace private
			?$ equ $
			iterate name, LIST, NEWPAGE, NOLIST, PAGE
				macro name?
				end macro
			end iterate
			iterate name, CPU, FILE, TITLE
				macro name? arg*
				end macro
			end iterate
			iterate name, COPY, INCLUDE
				macro name? path*
					include path
				end macro
			end iterate
			iterate name, EXTERN, EXTERNAL, REF, XREF
				macro name? symbols*
					match list : space, symbols
						name? list
					else
						iterate symbol, symbols
							symbol := global.symbol
						end iterate
					end match
				end macro
			end iterate
			iterate name, DEF, GLOBAL, PUBLIC, XDEF
				macro name? symbols*
					iterate symbol, symbols
						global.symbol := symbol
					end iterate
				end macro
			end iterate
			struc (symbol) EQU? expr*
				local error
				if ~defined error & defined symbol | error
					err 'Symbol "', `symbol, '" already defined'
					error = 1
				else
					error = 0
				end if
				?symbol = expr
			end struc
			iterate name, VAR, SET
				struc (symbol) name? expr*
					?symbol = expr
				end struc
			end iterate
			macro DS? count
				local c
				c = count
				rb c
			end macro
			struc DS? count
			.:	DS? count
			end struc
			iterate <def,blk,size*>, B,B,1, W,W,2, W24,P,3, L,L,4
				macro D#def? vals*&
					local v
					iterate val, vals
						v = val
						emit size: v
					end iterate
				end macro
				macro BLK#blk? count*, init
					local c, i
					c = count
					match, init
						emit size: c dup ?
					else
						i = init
						emit size: c dup i
					end match
				end macro
				iterate name, D#def, BLK#blk
					struc name? args&
					.:	name? args
					end struc
				end iterate
			end iterate
			macro ALIGN? val*
				local v
				v = val
				rb v-1 - ($ + v-1) mod v
			end macro
			macro SEGMENT? name*
				segment name
			end macro
			macro ASSUME? expr*
				namespace ez80
					assume? expr
				end namespace
			end macro
			iterate register, B, NZ, Z, NC, C, PO, PE, P, M, D, E,  \
			                  H, IXH, IYH, L, IXL, IYL, F, A, I, R, \
			                  MB, BC, DE, HL, IX, IY, SP, AF, AF'
				register? := ez80.register?
			end iterate
			irpv name, ez80.@ez80.oplist
				rmatch rname, name
					define rname rname
					iterate suffix, , .s?, .l?, .is?, .il?, .sis?, .sil?, .lis?, .lil?
						macro rname#suffix args&
							namespace ez80
								name#suffix args
							end namespace
						end macro
					end iterate
				end rmatch
			end irpv
			macro COMMENT? delim*&
				end match
				local inside
				inside = 0
				macro ?! line&
					local length, text
					length = 0
					if inside
						length = lengthof `line
						text = `line
					else if `line = 'end match'
						inside = 1
						length = lengthof `delim - 1
						text = `delim shr 8
					end if
					repeat length
						if ~text xor `delim and $FF
							purge ?
							break
						end if
						text = text shr 8
					end repeat
				end macro
			end macro
			macro END?!
				end if
				if 0
			end macro
			macro ? line&
				match .rest, line
					rest
				else match first= .rest, line
					first rest
				else
					line
				end match
			end macro
			if 1
				include file
			end if
			purge ?
		end namespace
	end macro
	macro src file
		local usedsrc
		usedsrc = 0
		checksrc file, usedsrc
		if usedsrc
			parsesrc file
		end if
	end macro

	macro symbol? args&
		iterate arg, args
			rmatch symbol == value, arg
				namespace segments
					global.symbol := value
				end namespace
			else
				'Syntax error in symbol arguments'
			end rmatch
		end iterate
	end macro
	macro entry? args&
		local use
		iterate arg, args
			use = global.arg
		end iterate
		restore use
	end macro

	iterate <name,result*>, files?,sources, libs?,libsources
		macro name args&
			iterate arg, args
				match first= rest, arg
					name first
					name rest
				else if `arg and $FF = "'"
					result equ arg
				else
					result equ `arg
				end if
			end iterate
		end macro
	end iterate

	macro locate? args&
		iterate arg, args
			rmatch name =at? location, arg
				segments equ segments.name?
				namespace segments
					name? := `name
					name.base? := location
				end namespace
			else
				err 'Syntax error in locate argument'
			end rmatch
		end iterate
	end macro
	macro range? args&
		iterate arg, args
			rmatch name lower : upper, arg
				locate name at lower
				namespace segments
					name.high? := upper
				end namespace
			else
				err 'Syntax error in range arguments'
			end rmatch
		end match
	end macro
	macro order? args&
		match first =, second =, rest, args
			order first, second
			order second, rest
		else match first =, second, args
			locate second at first.base + first.length
		else
			err 'Not enough order arguments'
		end match
	end macro
	macro merge? args&
		match name == list, args
			order list
			iterate each, list
				locate name at each.base
				indx %%
				namespace segments
					name.top? := each.base + each.length
					if defined each.high
						name.high? := each.high
					end if
				end namespace
				break
			end iterate
		else
			err 'Syntax error in merge arguments'
		end match
	end macro

	macro segment name*
		end virtual
		virtual segments.name.area
	end macro

	if ~defined sources
		err 'Please pass the input files with -i''files "file1" "file2" ...'''
	else if ~defined segments
		err 'No segments defined'
	else
		restore outbase, outtop ; forbid forward reference
		irpv each, segments
			namespace each
				virtual at base
				area?::
				end virtual
				if ~defined outbase | outbase > base & ~defined high
					outbase = base
				end if
			end namespace
		end irpv
		irpv each, libsources
			virtual segments.libs.area
				lib each
			end virtual
		end irpv
		irpv each, sources
			irpv first, segments
				virtual first.area
					src each
				end virtual
				break
			end irpv
		end irpv
		irpv each, segments
			namespace each
				virtual area
					top? := $
					length? := $ - $$
				end virtual
				if ~defined high
					if ~defined outtop | outtop < top
						outtop = top
					end if
				else if top > high
					repeat 1, len: length, over: top - high, max: high - base
						err 'Segment ', each, ' is ', `len, ' bytes, ',  \
						    `over, ' bytes larger than the maximum of ', \
						    `max, ' bytes'
					end repeat
				end if
			end namespace
		end irpv
		org outbase
		rb outtop - $
		postpone ?
			irpv each, segments
				namespace each
					if ~defined high
						load outtemp: length from area: base
						store outtemp: length at base
					end if
				end namespace
			end irpv
		end postpone
	end if
end macro
import
purge import
