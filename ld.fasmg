assert "\"" = '"' ; check for patched fasmg
include 'tiformat.inc'
define ez80 ez80
namespace ez80
	include 'ez80.inc'
end namespace
macro import $        : $        , \
             $$       : $$       , \
             and      : and      , \
             assert   : assert   , \
             at       : at       , \
             break    : break    , \
             define   : define   , \
             defined  : defined  , \
             display  : display  , \
             dup      : dup      , \
             else     : else     , \
             emit     : emit     , \
             end      : end      , \
             equ      : equ      , \
             err      : err      , \
             esc      : esc      , \
             eval     : eval     , \
             ez80     : ez80     , \
             from     : from     , \
             if       : if       , \
             include  : include  , \
             irpv     : irpv     , \
             iterate  : iterate  , \
             label    : label    , \
             lengthof : lengthof , \
             load     : load     , \
             local    : local    , \
             macro    : macro    , \
             match    : match    , \
             mod      : mod      , \
             namespace: namespace, \
             not      : not      , \
             or       : or       , \
             purge    : purge    , \
             rb       : rb       , \
             reequ    : reequ    , \
             repeat   : repeat   , \
             restore  : restore  , \
             restruc  : restruc  , \
             rmatch   : rmatch   , \
             segment  : segment  , \
             shl      : shl      , \
             shr      : shr      , \
             sources  : sources  , \
             store    : store    , \
             struc    : struc    , \
             used     : used     , \
             virtual  : virtual  , \
             while    : while    , \
             xor      : xor
	local global, debug, files, segments, hex, uleb128, output
	global equ
	files equ
	segments equ
	restore global, files, segments

	macro files.libs.parse file, offset, usedfunc, usedlib
		local private
		namespace private
			macro library?! name, version
				end if
					if usedlib
						emit 1: $C0, name, 0, version
					end if
				if 0
			end macro
			iterate each, export, export_pointer
				macro each?! function
					end if
						namespace ez80
							if used global._#function
								usedfunc = 1
							global._#function := $ + %-1
								jp offset
								virtual
									local name
									emit 1: '_', `function
									load name: $ - $$ from $$
									global equ name = global._#function
								end virtual
							end if
							offset = offset + word + @ez80.il
						end namespace
					if 0
				end macro
			end iterate
			if 0
				esc include! file
			end if
		end namespace
	end macro
	macro files.libs.handle file
		local offset, usedfunc, usedlib
		offset = 0
		usedfunc = 0
		files.libs.parse file, offset, usedfunc, usedlib
		usedlib = usedfunc
	end macro

	macro files.deps.check file, usedsrc
		local private
		namespace private
			iterate name, DEF, GLOBAL, PUBLIC, XDEF
				iterate style, name, .name
					macro style?! symbols*&
						end if
							iterate symbol, symbols
								if used global.symbol
									usedsrc = 1
								end if
							end iterate
						if 0
					end macro
				end iterate
			end iterate
			if 0
				esc include! file
			end if
		end namespace
	end macro
	macro files.parse file
		local private
		namespace private
			?$ equ $
			?XOR? equ xor
			?AND? equ and
			?OR?  equ or
			?SHL? equ shl
			?SHR? equ shr
			?NOT? equ not
			iterate name, LIST, NEWPAGE, NOLIST, PAGE
				macro name?
				end macro
			end iterate
			iterate name, CPU, TITLE
				macro name? arg*
				end macro
			end iterate
			macro DEFINE? args*&
			end macro
			iterate name, COPY, INCLUDE
				macro name? path*
					include path
				end macro
			end iterate
			iterate name, EXTERN, EXTERNAL, REF, XREF
				macro name? symbols*&
					match list : space, symbols
						name? list
					else
						iterate symbol, symbols
							symbol := global.symbol
						end iterate
					end match
				end macro
			end iterate
			iterate name, DEF, GLOBAL, PUBLIC, XDEF
				macro name? symbols*&
					iterate symbol, symbols
						global.symbol := symbol
						virtual
							local name
							emit 1: `symbol
							load name: $ - $$ from $$
							global equ name = global.symbol
						end virtual
					end iterate
				end macro
			end iterate
			struc (symbol) EQU? expr*
				local error
				if ~defined error & defined symbol | error
					err 'Symbol "', `symbol, '" already defined'
					error = 1
				else
					error = 0
				end if
				?symbol = expr
			end struc
			iterate name, VAR, SET
				struc (symbol) name? expr*
					?symbol = expr
				end struc
			end iterate
			macro DS? count
				local c
				c = count
				rb c
			end macro
			struc DS? count
			.:	DS? count
			end struc
			iterate <def,blk,size*>, B,B,1, W,W,2, W24,P,3, L,L,4
				macro D#def? vals*&
					local v
					iterate val, vals
						v = val
						emit size: v
					end iterate
				end macro
				macro BLK#blk? count*, init
					local c, i
					c = count
					match, init
						emit size: c dup ?
					else
						i = init
						emit size: c dup i
					end match
				end macro
				iterate name, D#def, BLK#blk
					struc name? args&
					.:	name? args
					end struc
				end iterate
			end iterate
			iterate <name,alias*>, TRIO,DW24, DF,DL
				macro name? vals*&
					alias? vals
				end macro
				struc name? args&
				.:	name? args
				end struc
			end iterate
			macro ALIGN? val*
				local v
				v = val
				rb v-1 - ($ + v-1) mod v
			end macro
			macro SEGMENT? name*
				segment name
			end macro
			macro ASSUME? expr*
				namespace ez80
					assume? expr
				end namespace
			end macro
			iterate register, B, NZ, Z, NC, C, PO, PE, P, M, D, E,  \
			                  H, IXH, IYH, L, IXL, IYL, F, A, I, R, \
			                  MB, BC, DE, HL, IX, IY, SP, AF, AF'
				register? := ez80.register?
			end iterate
			iterate suffix, , .s?, .l?, .is?, .il?, .sis?, .sil?, .lis?, .lil?
				irpv name, ez80.@ez80.oplist
					rmatch rname, name
						define rname rname
						macro rname#suffix args&
							namespace ez80
								name#suffix args
							end namespace
						end macro
					end rmatch
				end irpv
				macro LD? d, s*
					namespace ez80
						@ez80.classify dst, dstind, d
						@ez80.classify src, srcind, s
						if ~dstind & dst eq dst element 1 & dst @ez80.is_reg @ez80.wreg \
						 & dst metadata 1 scale 1 and 001o & ~srcind                    \
						 & src relativeto src element 1 & src @ez80.is_reg @ez80.wreg
							if src metadata 1 scale 1 = 007o
								PUSH? s
								POP? d
							else
								LEA? d, s
							end if
						else
							LD? d, s
						end if
					end namespace
				end macro
				macro JR?#suffix args&
					namespace ez80
						jq?#suffix args
					end namespace
				end macro
			end iterate
			iterate <name,carry>, UEXT,<OR? A?,A>, SEXT,RLA
				macro name? reg*
					carry?
					SBC? reg, reg
				end macro
			end iterate
			macro COMMENT? delim*&
				end match
				local inside
				inside = 0
				macro ?! line&
					local length, text
					length = 0
					if inside
						length = lengthof `line
						text = `line
					else if `line = 'end match'
						inside = 1
						length = lengthof `delim - 1
						text = `delim shr 8
					end if
					repeat length
						if ~text xor `delim and $FF
							purge ?
							break
						end if
						text = text shr 8
					end repeat
				end macro
			end macro

			if defined debug
				debug.emit = 0
				macro ALIAS? args&
				end macro
				macro BEGFUNC? args&
				end macro
				macro BEGREC? args&
				end macro
				macro CLASS? args&
				end macro
				macro LENGTH? args&
				end macro
				macro DEBUG? lang*
					assert lang = 'C'
					debug.emit = 1
					debug.addr = $
					debug.line = 0
					virtual debug
						uleb128 lengthof debug.source
						emit 1: debug.source
						uleb128 debug.addr
					end virtual
				end macro
				macro DEFINE? args&
				end macro
				macro DIM? args&
				end macro
				macro ENDEF? args&
				end macro
				macro ENDFUNC? args&
				end macro
				macro ENDREC? args&
				end macro
				macro FILE? name*
					debug.source = name
				end macro
				macro LINE? num
					if debug.emit
						local addr, line
						addr = $
						line = num
						assert line <> debug.line
						if addr <> debug.addr
							virtual debug
								uleb128 addr - debug.addr, line - debug.line
							end virtual
							debug.addr = addr
							debug.line = line
						end if
					end if
				end macro
				macro PHONY? args&
				end macro
				macro TAG? args&
				end macro
				macro TYPE? args&
				end macro
				macro VALUE? args&
				end macro
			else
				iterate name, ALIAS, BEGFUNC, BEGREC, CLASS, DEBUG, DEFINE,   \
				              DIM, ENDEF, ENDFUNC, ENDREC, FILE, LINE, PHONY, \
				              TAG, TYPE, VALUE
					macro name? args&
					end macro
				end iterate
			end if

			macro END?!
				end if
				if 0
			end macro
			struc ? def::&
				. def
			end struc
			macro ? line&
				match .rest, line
					rest
				else match first= .rest, line
					first rest
				else
					line
				end match
			end macro
			if 1
				include file
			end if
			purge ?
			restruc ?

			if defined debug & debug.emit
				segment code
				debug.addr = $ - debug.addr
				virtual debug
					uleb128 debug.addr, 0
				end virtual
				restore debug.emit, debug.addr, debug.line
			end if
		end namespace
	end macro
	macro files.handle file
		files.parse file
	end macro
	macro files.deps.handle file
		local usedsrc
		usedsrc = 0
		files.deps.check file, usedsrc
		if usedsrc
			files.parse file
		end if
	end macro

	macro symbol? args&
		iterate arg, args
			rmatch symbol == value, arg
				namespace segments
					global.symbol := value
					virtual
						local name
						emit 1: `symbol
						load name: $ - $$ from $$
						global equ = name global.symbol
					end virtual
				end namespace
			else
				'Syntax error in symbol arguments'
			end rmatch
		end iterate
	end macro

	iterate name, deps, libs
		macro name? args*&
			iterate arg, args
				match first= rest, arg
					name? first
					name? rest
				else if `arg and $FF = "'"
					files.name equ arg
				else
					files.name equ `arg
				end if
			end iterate
		end macro
	end iterate
	macro sources? args*&
		iterate arg, args
			rmatch file =if? cond, arg
				namespace segments
					if cond
						sources? file
					end if
				end namespace
			else match first= rest, arg
				sources? first
				sources? rest
			else if `arg and $FF = "'"
				files equ arg
			else
				files equ `arg
			end if
		end iterate
	end macro

	macro locate? args&
		iterate arg, args
			rmatch name =at? location, arg
				segments equ segments.name?
				namespace segments
					name? := `name
					name.base? := location
				end namespace
			else
				err 'Syntax error in locate argument'
			end rmatch
		end iterate
	end macro
	macro range? args&
		iterate arg, args
			rmatch name lower : upper, arg
				locate name at lower
				namespace segments
					name.high? := upper
				end namespace
			else
				err 'Syntax error in range arguments'
			end rmatch
		end iterate
	end macro
	macro order? args&
		match first =, second =, rest, args
			order first, second
			order second, rest
		else match first =, second, args
			locate second at first.base + first.length
		else
			err 'Not enough order arguments'
		end match
	end macro
	macro merge? args&
		match name == list, args
			order list
			iterate segment, list
				locate name at segment.base
				indx %%
				namespace segments
					name.top? := segment.base + segment.length
					if defined segment.high
						name.high? := segment.high
					end if
				end namespace
				break
			end iterate
		else
			err 'Syntax error in merge arguments'
		end match
	end macro

	macro hex value*, leading: '0', digits: 6
		local val, zero, digit, char
		emit 1: ' '
		val = value
		zero = leading
		repeat digits
			digit = (val shr ((%% - %) shl 2)) and 0Fh
			if digit < 10
				char = '0' + digit
			else
				char = 'A' + digit - 10
			end if
			if digit
				zero = '0'
			else if % <> %%
				char = zero
			end if
			emit 1: char
		end repeat
	end macro
	macro uleb128 values&
		iterate value, values
			local val
			val = value
			assert val >= 0
			while val and not 07Fh
				emit 1: val and 07Fh or 080h
				val = val shr 7
			end while
			emit 1: val
		end iterate
	end macro

	macro map?
		local longest, name
		postpone ?
			virtual as 'map'
				longest = lengthof "Segment"
				irpv segment, segments
					if longest < lengthof segment
						longest = lengthof segment
					end if
				end irpv
				emit 1: "Segment", longest - lengthof "Segment" + 1 dup ' ', "Base   Top    High   Length", 10, longest dup '-', 4 dup " ------", '-', 10
				irpv segment, segments
					namespace segment
						if longest < lengthof segment
							longest = lengthof segment
						end if
						emit 1: segment, longest - lengthof segment dup ' '
						hex base
						hex top
						if defined high
							hex high
						else
							emit 1: 7 dup ' '
						end if
						hex length, ' '
						emit 1: 'h', 10
					end namespace
				end irpv
				match any, global
					longest = lengthof "Label"
					irpv symbol, global
						match name == value, symbol
							if longest < lengthof name
								longest = lengthof name
							end if
						end match
					end irpv
					emit 1: 10, "Label", longest - lengthof "Label" + 3 dup ' ', "Value", 10, longest dup '-', 3 dup ' ', 6 dup '-', 10
					irpv symbol, global
						match name == value, symbol
							emit 1: name, longest - lengthof name + 1 dup ' ', '='
							hex value
							emit 1: 10
						end match
					end irpv
				end match
			end virtual
		end postpone
	end macro
	macro dbg?
		virtual as 'dbg'
		debug::
		end virtual
	end macro

	macro segment name*
		end virtual
		virtual segments.name.area
	end macro

	if ~defined files
		err 'Please pass the input files with -i\'sources "file1" [if "cond1"], "file2" [if "cond2"], ...\''
	else if ~defined segments
		err 'No segments defined'
	else
		restore output.base, output.top ; forbid forward reference
		irpv segment, segments
			namespace segment
				virtual at base
				area?::
				end virtual
				if ~defined output.base | output.base > base & ~defined high
					output.base = base
				end if
			end namespace
		end irpv
		irpv file, files
			virtual segments.code.area
				files.handle file
			end virtual
		end irpv
		irpv file, files.deps
			virtual segments.code.area
				files.deps.handle file
			end virtual
		end irpv
		irpv file, files.libs
			virtual segments.libs.area
				files.libs.handle file
			end virtual
		end irpv
		irpv segment, segments
			namespace segment
				virtual area
					top? := $
					length? := $ - $$
				end virtual
				if ~defined high
					if ~defined output.top | output.top < top
						output.top = top
					end if
				else if top > high
					repeat 1, len: length, over: top - high, max: high - base
						err 'Segment ', segment, ' is ', `len, ' bytes, ',  \
						    `over, ' bytes larger than the maximum of ', \
						    `max, ' bytes'
					end repeat
				end if
			end namespace
		end irpv
		org output.base
		rb output.top - $
		postpone ?
			irpv segment, segments
				namespace segment
					if ~defined high
						load output: length from area: base
						store output: length at base
					end if
				end namespace
			end irpv
		end postpone
	end if
end macro
import
purge import
